-- main pipeline script
-- moves and process data from external source through staging up to data mart


-- run initialization
-- inserts a new run record into dwh.etl_runs and captures ID in a temp table named current_run (session scoped)
-- INSERT ... RETURNING captures the exact run_id generated by this session
-- DROP + CREATE - so the temp table is always rebuilt fresh even if the pipeline is re-executed within same session
DROP TABLE IF EXISTS current_run;
CREATE TEMP TABLE current_run (run_id BIGINT);

BEGIN;
WITH new_run AS (INSERT INTO dwh.etl_runs (started_at, status)
                 VALUES (CURRENT_TIMESTAMP, 'RUNNING')
                 RETURNING run_id)
INSERT INTO current_run (run_id)
SELECT run_id FROM new_run
;
COMMIT;


-- dq logging - source.raw_customers

-- catches records with missing company_name, country, or signup_date
-- detail lists exactly which columns are NULL for faster investigation
BEGIN;
INSERT INTO dwh.dq_log (run_id, last_seen_run_id, table_name, record_id, issue_type, detail)
SELECT (SELECT run_id FROM current_run),
       (SELECT run_id FROM current_run),
        'source.raw_customers',
        customer_id,
        'NULL_VALUE',
        CONCAT_WS(', ',
           CASE WHEN company_name IS NULL THEN 'company_name IS NULL' END,
           CASE WHEN country IS NULL THEN 'country IS NULL' END,
           CASE WHEN signup_date IS NULL THEN 'signup_date IS NULL' END)
FROM source.raw_customers
WHERE company_name IS NULL
OR country IS NULL
OR signup_date IS NULL
ON CONFLICT (table_name, record_id, issue_type) DO UPDATE
    SET last_seen_run_id = EXCLUDED.last_seen_run_id,
        detail = EXCLUDED.detail
;


-- catches records where signup_date falls outside the expected range (2020-2030)
INSERT INTO dwh.dq_log (run_id, last_seen_run_id, table_name, record_id, issue_type, detail)
SELECT (SELECT run_id FROM current_run),
       (SELECT run_id FROM current_run),
        'source.raw_customers',
        customer_id,
        'DATE_OUT_OF_RANGE',
        'signup_date = ' || signup_date::TEXT
FROM source.raw_customers
WHERE signup_date IS NOT NULL
AND (signup_date < '2020-01-01' 
OR signup_date > '2030-12-31')
ON CONFLICT (table_name, record_id, issue_type) DO UPDATE
    SET last_seen_run_id = EXCLUDED.last_seen_run_id,
        detail = EXCLUDED.detail
;


-- catches duplicated records
-- composite/natural key: company_name + country + signup_date
-- UPPER is used on company_name and country because these are columns where case differences are likely typos - please see the documentation
WITH duplicated AS (SELECT UPPER(company_name) AS company_name,
                           UPPER(country) AS country,
                           signup_date,
                           MIN(customer_id) AS min_id
                    FROM source.raw_customers
                    WHERE company_name IS NOT NULL
                    AND country IS NOT NULL
                    AND signup_date IS NOT NULL
                    GROUP BY UPPER(company_name),
                             UPPER(country),
                             signup_date
                    HAVING COUNT(*) > 1)
INSERT INTO dwh.dq_log (run_id, last_seen_run_id, table_name, record_id, issue_type, detail)
SELECT (SELECT run_id FROM current_run),
       (SELECT run_id FROM current_run),
        'source.raw_customers',
        c.customer_id,
        'DUPLICATE',
        'duplicate of customer_id = ' || d.min_id
FROM source.raw_customers AS c
INNER JOIN duplicated AS d
ON UPPER(c.company_name) = d.company_name
AND UPPER(c.country) = d.country
AND c.signup_date = d.signup_date
WHERE c.customer_id > d.min_id
ON CONFLICT (table_name, record_id, issue_type) DO UPDATE
    SET last_seen_run_id = EXCLUDED.last_seen_run_id,
        detail = EXCLUDED.detail
;
COMMIT;


-- dq logging - source.raw_subscriptions

-- catches records with missing customer_id, plan_type, or start_date
BEGIN;
INSERT INTO dwh.dq_log (run_id, last_seen_run_id, table_name, record_id, issue_type, detail)
SELECT (SELECT run_id FROM current_run),
       (SELECT run_id FROM current_run),
        'source.raw_subscriptions',
        sub_id,
        'NULL_VALUE',
        CONCAT_WS(', ',
           CASE WHEN customer_id IS NULL THEN 'customer_id IS NULL' END,
           CASE WHEN plan_type IS NULL THEN 'plan_type IS NULL' END,
           CASE WHEN start_date IS NULL THEN 'start_date IS NULL' END)
FROM source.raw_subscriptions
WHERE customer_id IS NULL
OR plan_type IS NULL
OR start_date IS NULL
ON CONFLICT (table_name, record_id, issue_type) DO UPDATE
    SET last_seen_run_id = EXCLUDED.last_seen_run_id,
        detail = EXCLUDED.detail
;


-- catches records where plan_type is not NULL but does not match the list of allowed categories
INSERT INTO dwh.dq_log (run_id, last_seen_run_id, table_name, record_id, issue_type, detail)
SELECT (SELECT run_id FROM current_run),
       (SELECT run_id FROM current_run),
        'source.raw_subscriptions',
        sub_id,
        'INVALID_CATEGORY',
        'plan_type = ' || plan_type
FROM source.raw_subscriptions
WHERE plan_type IS NOT NULL
AND plan_type NOT IN ('Monthly', 'Annual')
ON CONFLICT (table_name, record_id, issue_type) DO UPDATE
    SET last_seen_run_id = EXCLUDED.last_seen_run_id,
        detail = EXCLUDED.detail
;


-- catches records where end_date comes before start_date
INSERT INTO dwh.dq_log (run_id, last_seen_run_id, table_name, record_id, issue_type, detail)
SELECT (SELECT run_id FROM current_run),
       (SELECT run_id FROM current_run),
        'source.raw_subscriptions',
        sub_id,
        'DATE_LOGIC_ERROR_DATES',
        'end_date (' || end_date::TEXT || ') < start_date (' || start_date::TEXT || ')'
FROM source.raw_subscriptions
WHERE end_date IS NOT NULL
AND start_date IS NOT NULL
AND end_date < start_date
ON CONFLICT (table_name, record_id, issue_type) DO UPDATE
    SET last_seen_run_id = EXCLUDED.last_seen_run_id,
        detail = EXCLUDED.detail
;


-- catches records where the linked customer's signup_date appears after the subscription start_date
-- please see the documentation for explanation about distinction between previous DATE_LOGIC_ERROR_DATES and DATE_LOGIC_ERROR_SIGNUP
INSERT INTO dwh.dq_log (run_id, last_seen_run_id, table_name, record_id, issue_type, detail)
SELECT (SELECT run_id FROM current_run),
       (SELECT run_id FROM current_run),
        'source.raw_subscriptions',
        s.sub_id,
        'DATE_LOGIC_ERROR_SIGNUP',
        'signup_date (' || c.signup_date::TEXT || ') > start_date (' || s.start_date::TEXT || ')'
FROM source.raw_subscriptions AS s
INNER JOIN source.raw_customers AS c
ON c.customer_id = s.customer_id
WHERE c.signup_date IS NOT NULL
AND s.start_date IS NOT NULL
AND c.signup_date > s.start_date
ON CONFLICT (table_name, record_id, issue_type) DO UPDATE
    SET last_seen_run_id = EXCLUDED.last_seen_run_id,
        detail = EXCLUDED.detail
;


-- catches records where start_date or end_date falls outside the expected range (2020-2030)
INSERT INTO dwh.dq_log (run_id, last_seen_run_id, table_name, record_id, issue_type, detail)
SELECT (SELECT run_id FROM current_run),
       (SELECT run_id FROM current_run),
        'source.raw_subscriptions',
        sub_id,
        'DATE_OUT_OF_RANGE',
        CONCAT_WS(', ',
           CASE WHEN start_date IS NOT NULL
                 AND (start_date < '2020-01-01' OR start_date > '2030-12-31')
                 THEN 'start_date = ' || start_date::TEXT END,
           CASE WHEN end_date IS NOT NULL
                 AND (end_date < '2020-01-01' OR end_date > '2030-12-31')
                 THEN 'end_date = ' || end_date::TEXT END)
FROM source.raw_subscriptions
WHERE (start_date IS NOT NULL AND (start_date < '2020-01-01' OR start_date > '2030-12-31'))
OR (end_date IS NOT NULL AND (end_date < '2020-01-01' OR end_date > '2030-12-31'))
ON CONFLICT (table_name, record_id, issue_type) DO UPDATE
    SET last_seen_run_id = EXCLUDED.last_seen_run_id,
        detail = EXCLUDED.detail
;


-- catches records where amount is a negative number
INSERT INTO dwh.dq_log (run_id, last_seen_run_id, table_name, record_id, issue_type, detail)
SELECT (SELECT run_id FROM current_run),
       (SELECT run_id FROM current_run),
        'source.raw_subscriptions',
        sub_id,
        'NEGATIVE_NUMBER',
        'amount = ' || amount::TEXT
FROM source.raw_subscriptions
WHERE amount IS NOT NULL
AND amount < 0
ON CONFLICT (table_name, record_id, issue_type) DO UPDATE
    SET last_seen_run_id = EXCLUDED.last_seen_run_id,
        detail = EXCLUDED.detail
;


-- catches duplicated records
-- composite/natural key: customer_id + plan_type + start_date
WITH duplicated AS (SELECT customer_id,
                           plan_type,
                           start_date,
                           MIN(sub_id) AS min_id
                    FROM source.raw_subscriptions
                    WHERE customer_id IS NOT NULL
                    AND plan_type IS NOT NULL
                    AND start_date IS NOT NULL
                    GROUP BY customer_id,
                             plan_type,
                             start_date
                    HAVING COUNT(*) > 1)
INSERT INTO dwh.dq_log (run_id, last_seen_run_id, table_name, record_id, issue_type, detail)
SELECT (SELECT run_id FROM current_run),
       (SELECT run_id FROM current_run),
       'source.raw_subscriptions',
       s.sub_id,
       'DUPLICATE',
       'duplicate of sub_id = ' || d.min_id
FROM source.raw_subscriptions AS s
INNER JOIN duplicated AS d
ON d.customer_id = s.customer_id
AND d.plan_type = s.plan_type
AND d.start_date = s.start_date
WHERE s.sub_id > d.min_id
ON CONFLICT (table_name, record_id, issue_type) DO UPDATE
    SET last_seen_run_id = EXCLUDED.last_seen_run_id,
        detail = EXCLUDED.detail
;


-- catches subscriptions where customer_id has no matching record in source.raw_customers
INSERT INTO dwh.dq_log (run_id, last_seen_run_id, table_name, record_id, issue_type, detail)
SELECT (SELECT run_id FROM current_run),
       (SELECT run_id FROM current_run),
        'source.raw_subscriptions',
        s.sub_id,
        'MISSING_FK',
        'customer_id = ' || s.customer_id || ' not found in source.raw_customers'
FROM source.raw_subscriptions AS s
WHERE s.customer_id IS NOT NULL
AND NOT EXISTS (SELECT 1
                FROM source.raw_customers AS c
                WHERE c.customer_id = s.customer_id)
ON CONFLICT (table_name, record_id, issue_type) DO UPDATE
    SET last_seen_run_id = EXCLUDED.last_seen_run_id,
        detail = EXCLUDED.detail
;
COMMIT;


-- dq logging - source.raw_transactions

-- catches records with missing sub_id, tx_date, or status
BEGIN;
INSERT INTO dwh.dq_log (run_id, last_seen_run_id, table_name, record_id, issue_type, detail)
SELECT (SELECT run_id FROM current_run),
       (SELECT run_id FROM current_run),
        'source.raw_transactions',
        tx_id,
        'NULL_VALUE',
        CONCAT_WS(', ',
           CASE WHEN sub_id IS NULL THEN 'sub_id IS NULL' END,
           CASE WHEN tx_date IS NULL THEN 'tx_date IS NULL' END,
           CASE WHEN status IS NULL THEN 'status IS NULL' END)
FROM source.raw_transactions
WHERE sub_id IS NULL
OR tx_date IS NULL
OR status IS NULL
ON CONFLICT (table_name, record_id, issue_type) DO UPDATE
    SET last_seen_run_id = EXCLUDED.last_seen_run_id,
        detail = EXCLUDED.detail
;


-- catches records where status is not NULL but does not match the list of allowed categories
INSERT INTO dwh.dq_log (run_id, last_seen_run_id, table_name, record_id, issue_type, detail)
SELECT (SELECT run_id FROM current_run),
       (SELECT run_id FROM current_run),
        'source.raw_transactions',
        tx_id,
        'INVALID_CATEGORY',
        'status = ' || status
FROM source.raw_transactions
WHERE status IS NOT NULL
AND status NOT IN ('Success', 'Failed', 'Refunded')
ON CONFLICT (table_name, record_id, issue_type) DO UPDATE
    SET last_seen_run_id = EXCLUDED.last_seen_run_id,
        detail = EXCLUDED.detail
;


-- catches records where tx_date starts before the linked subscription start_date
INSERT INTO dwh.dq_log (run_id, last_seen_run_id, table_name, record_id, issue_type, detail)
SELECT (SELECT run_id FROM current_run),
       (SELECT run_id FROM current_run),
        'source.raw_transactions',
        t.tx_id,
        'DATE_LOGIC_ERROR_DATES',
        'tx_date (' || t.tx_date::TEXT || ') < start_date (' || s.start_date::TEXT || ')'
FROM source.raw_transactions AS t
INNER JOIN source.raw_subscriptions AS s
ON s.sub_id = t.sub_id
WHERE t.tx_date IS NOT NULL
AND s.start_date IS NOT NULL
AND t.tx_date < s.start_date
ON CONFLICT (table_name, record_id, issue_type) DO UPDATE
    SET last_seen_run_id = EXCLUDED.last_seen_run_id,
        detail = EXCLUDED.detail
;


-- catches records where tx_date falls outside the expected range (2020-2030)
INSERT INTO dwh.dq_log (run_id, last_seen_run_id, table_name, record_id, issue_type, detail)
SELECT (SELECT run_id FROM current_run),
       (SELECT run_id FROM current_run),
        'source.raw_transactions',
        tx_id,
        'DATE_OUT_OF_RANGE',
        'tx_date = ' || tx_date::TEXT
FROM source.raw_transactions
WHERE tx_date IS NOT NULL
AND (tx_date < '2020-01-01' OR tx_date > '2030-12-31')
ON CONFLICT (table_name, record_id, issue_type) DO UPDATE
    SET last_seen_run_id = EXCLUDED.last_seen_run_id,
        detail = EXCLUDED.detail
;


-- catches duplicated records
-- composite/natural key: sub_id + tx_date + status
WITH duplicated AS (SELECT sub_id,
                           tx_date,
                           status,
                           MIN(tx_id) AS min_id
                    FROM source.raw_transactions
                    WHERE sub_id IS NOT NULL
                    AND tx_date IS NOT NULL
                    AND status IS NOT NULL
                    GROUP BY sub_id,
                             tx_date,
                             status
                    HAVING COUNT(*) > 1)
INSERT INTO dwh.dq_log (run_id, last_seen_run_id, table_name, record_id, issue_type, detail)
SELECT (SELECT run_id FROM current_run),
       (SELECT run_id FROM current_run),
        'source.raw_transactions',
        t.tx_id,
        'DUPLICATE',
        'duplicate of tx_id = ' || d.min_id
FROM source.raw_transactions AS t
INNER JOIN duplicated AS d
ON d.sub_id = t.sub_id
AND d.tx_date = t.tx_date
AND d.status = t.status
WHERE t.tx_id > d.min_id
ON CONFLICT (table_name, record_id, issue_type) DO UPDATE
    SET last_seen_run_id = EXCLUDED.last_seen_run_id,
        detail = EXCLUDED.detail
;


-- catches records where sub_id has no matching record in source.raw_subscriptions
INSERT INTO dwh.dq_log (run_id, last_seen_run_id, table_name, record_id, issue_type, detail)
SELECT (SELECT run_id FROM current_run),
       (SELECT run_id FROM current_run),
        'source.raw_transactions',
        t.tx_id,
        'MISSING_FK',
        'sub_id = ' || t.sub_id || ' not found in source.raw_subscriptions'
FROM source.raw_transactions AS t
WHERE t.sub_id IS NOT NULL
AND NOT EXISTS (SELECT 1
                FROM source.raw_subscriptions AS s
                WHERE s.sub_id = t.sub_id)
ON CONFLICT (table_name, record_id, issue_type) DO UPDATE
    SET last_seen_run_id = EXCLUDED.last_seen_run_id,
        detail = EXCLUDED.detail
;
COMMIT;


-- STAGING UPSERTS

-- upsert into dwh.stg_customers
BEGIN;
WITH deduped AS (SELECT customer_id,
                        company_name,
                        country,
                        signup_date,
                        ROW_NUMBER() OVER (PARTITION BY UPPER(company_name),
                                                        UPPER(country),
                                                        signup_date
                                           ORDER BY customer_id ASC) AS rn
                 FROM source.raw_customers
                 WHERE company_name IS NOT NULL
                 AND country IS NOT NULL
                 AND signup_date IS NOT NULL
                 AND signup_date BETWEEN '2020-01-01' AND '2030-12-31')
INSERT INTO dwh.stg_customers (customer_id,
                               company_name,
                               country,
                               signup_date,
                               created_at,
                               updated_at)
SELECT customer_id,
       company_name,
       country,
       signup_date,
       CURRENT_TIMESTAMP,
       CURRENT_TIMESTAMP
FROM deduped
WHERE rn = 1
ON CONFLICT (customer_id) DO UPDATE
    SET company_name = EXCLUDED.company_name,
        country = EXCLUDED.country,
        signup_date = EXCLUDED.signup_date,
        updated_at = CURRENT_TIMESTAMP
;
COMMIT;


-- upsert into dwh.stg_subscriptions
BEGIN;
WITH deduped AS (SELECT s.sub_id,
                        s.customer_id,
                        s.plan_type,
                        s.start_date,
                        s.end_date,
                        s.amount,
                        ROW_NUMBER() OVER (PARTITION BY s.customer_id,
                                                        s.plan_type,
                                                        s.start_date
                                           ORDER BY s.sub_id ASC) AS rn
                 FROM source.raw_subscriptions AS s
                 INNER JOIN dwh.stg_customers AS c
                 ON c.customer_id = s.customer_id
                 WHERE s.customer_id IS NOT NULL
                 AND s.plan_type IS NOT NULL
                 AND s.start_date IS NOT NULL
                 AND s.plan_type IN ('Monthly', 'Annual')
                 AND (s.end_date IS NULL OR s.end_date >= s.start_date)
                 AND s.start_date BETWEEN '2020-01-01' AND '2030-12-31'
                 AND (s.end_date IS NULL OR s.end_date BETWEEN '2020-01-01' AND '2030-12-31')
                 AND (s.amount IS NULL OR s.amount >= 0)
                 AND c.signup_date <= s.start_date)
INSERT INTO dwh.stg_subscriptions (sub_id,
                                   customer_id,
                                   plan_type,
                                   start_date,
                                   end_date,
                                   amount,
                                   created_at,
                                   updated_at)
SELECT sub_id,
       customer_id,
       plan_type,
       start_date,
       end_date,
       amount,
       CURRENT_TIMESTAMP,
       CURRENT_TIMESTAMP
FROM deduped
WHERE rn = 1
ON CONFLICT (sub_id) DO UPDATE
    SET customer_id = EXCLUDED.customer_id,
        plan_type = EXCLUDED.plan_type,
        start_date = EXCLUDED.start_date,
        end_date = EXCLUDED.end_date,
        amount = EXCLUDED.amount,
        updated_at = CURRENT_TIMESTAMP
;
COMMIT;


-- upsert into dwh.stg_transactions
BEGIN;
WITH deduped AS (SELECT t.tx_id,
                        t.sub_id,
                        t.tx_date,
                        t.status,
                        ROW_NUMBER() OVER (PARTITION BY t.sub_id,
                                                        t.tx_date,
                                                        t.status
                                           ORDER BY t.tx_id ASC) AS rn
                 FROM source.raw_transactions AS t
                 INNER JOIN dwh.stg_subscriptions AS s
                 ON s.sub_id = t.sub_id
                 WHERE t.sub_id IS NOT NULL
                 AND t.tx_date IS NOT NULL
                 AND t.status IS NOT NULL
                 AND t.status IN ('Success', 'Failed', 'Refunded')
                 AND t.tx_date >= s.start_date
                 AND t.tx_date BETWEEN '2020-01-01' AND '2030-12-31')
INSERT INTO dwh.stg_transactions (tx_id,
                                  sub_id,
                                  tx_date,
                                  status,
                                  created_at,
                                  updated_at)
SELECT tx_id,
       sub_id,
       tx_date,
       status,
       CURRENT_TIMESTAMP,
       CURRENT_TIMESTAMP
FROM deduped
WHERE rn = 1
ON CONFLICT (tx_id) DO UPDATE
    SET sub_id = EXCLUDED.sub_id,
        tx_date = EXCLUDED.tx_date,
        status = EXCLUDED.status,
        updated_at = CURRENT_TIMESTAMP
;
COMMIT;


-- data mart 

-- upsert into dwh.dm_sales_performance
-- stores 1 subscription per row
-- all metrics are recalculated on every run 
-- no business logic applied that is not already enforced earlier/upstream
-- subscription_duration: difference in days between end_date and start_date (NULL for active subscriptions)
-- total_successful_payments: count of transactions with status "Success" 
-- sum_successful_payments: sum of money made on basis of successful payments
-- please see the documentation for explanation for introducing both the total_successful_payments and sum_successful_payments
BEGIN;
INSERT INTO dwh.dm_sales_performance (sub_id,
                                      company_name,
                                      country,
                                      subscription_duration,
                                      total_successful_payments,
                                      sum_successful_payments,
                                      updated_at)
SELECT s.sub_id,
       c.company_name,
       c.country,
       (s.end_date - s.start_date) AS subscription_duration,
       COUNT(t.tx_id) FILTER (WHERE t.status = 'Success') AS total_successful_payments,
       COALESCE(SUM(CASE WHEN t.status = 'Success' THEN s.amount END), 0) AS sum_successful_payments,
       CURRENT_TIMESTAMP AS updated_at
FROM dwh.stg_subscriptions AS s
INNER JOIN dwh.stg_customers AS c
ON c.customer_id = s.customer_id
LEFT JOIN dwh.stg_transactions AS t
ON t.sub_id = s.sub_id
GROUP BY s.sub_id,
         c.company_name,
         c.country,
         s.end_date,
         s.start_date,
         s.amount
ON CONFLICT (sub_id) DO UPDATE
    SET company_name = EXCLUDED.company_name,
        country = EXCLUDED.country,
        subscription_duration = EXCLUDED.subscription_duration,
        total_successful_payments = EXCLUDED.total_successful_payments,
        sum_successful_payments = EXCLUDED.sum_successful_payments,
        updated_at = CURRENT_TIMESTAMP
;
COMMIT;


-- pipeline completion insert block
-- marks the current run as completed
-- if the pipeline fails before reaching this point, ended_at column is NULL and status is RUNNING
-- idea is to provide a bit more observability - run without COMPLETED status means some failure happened
BEGIN;
UPDATE dwh.etl_runs
SET ended_at = CURRENT_TIMESTAMP,
    status = 'COMPLETED'
WHERE run_id = (SELECT run_id 
                FROM current_run)
;
COMMIT;


-- ad-hoc queries for quic summary across all pipeline layers/stages
-- uncomment and run after all the code above to check the summary along with DQ issues found during pipeline run

/*

-- overview of DQ log table
SELECT * 
FROM dwh.dq_log;

SELECT (SELECT run_id
        FROM current_run) AS run_id,
       (SELECT started_at
        FROM dwh.etl_runs
        WHERE run_id = (SELECT run_id 
                        FROM current_run)) AS run_started_at,
       (SELECT ended_at
        FROM dwh.etl_runs
        WHERE run_id = (SELECT run_id 
                        FROM current_run)) AS run_ended_at,
       (SELECT status
        FROM dwh.etl_runs
        WHERE run_id = (SELECT run_id 
                        FROM current_run)) AS run_status,
       (SELECT COUNT(*) 
        FROM source.raw_customers) AS source_customers,
       (SELECT COUNT(*) 
        FROM dwh.stg_customers) AS staging_customers,
       (SELECT COUNT(*) 
        FROM source.raw_subscriptions) AS source_subscriptions,
       (SELECT COUNT(*) 
        FROM dwh.stg_subscriptions) AS staging_subscriptions,
       (SELECT COUNT(*) 
        FROM source.raw_transactions) AS source_transactions,
       (SELECT COUNT(*) 
        FROM dwh.stg_transactions) AS staging_transactions,
       (SELECT COUNT(*) 
        FROM dwh.dm_sales_performance) AS datamart_records,
       (SELECT COUNT(*) 
        FROM dwh.dq_log
        WHERE run_id = (SELECT run_id 
                        FROM current_run)) AS dq_issues_new_this_run,
       (SELECT COUNT(*) 
        FROM dwh.dq_log
        WHERE last_seen_run_id = (SELECT run_id 
                                  FROM current_run)
        AND run_id < (SELECT run_id 
                      FROM current_run)) AS dq_issues_persisted_this_run,
       (SELECT COUNT(*) 
        FROM dwh.dq_log) AS dq_issues_all_time
;

-- DQ issues detail for pipeline execution, by table and type
-- new = first detected this run
-- persisted = detected earlier but still present
SELECT table_name,
       issue_type,
       COUNT(*) FILTER (WHERE run_id = (SELECT run_id 
                                        FROM current_run)) AS new_count,
       COUNT(*) FILTER (WHERE run_id < (SELECT run_id 
                                        FROM current_run)) AS persisted_count,
       COUNT(*) AS total_count
FROM dwh.dq_log
WHERE last_seen_run_id = (SELECT run_id 
                          FROM current_run)
GROUP BY table_name,
         issue_type
ORDER BY table_name,
         issue_type
;

*/